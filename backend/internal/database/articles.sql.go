// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (user_id, title, body, summary, thumbnail_url, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, title, body, summary, thumbnail_url, status, published_at, created_at, updated_at, search_vector
`

type CreateArticleParams struct {
	UserID       uuid.UUID
	Title        string
	Body         string
	Summary      string
	ThumbnailUrl string
	Status       string
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.UserID,
		arg.Title,
		arg.Body,
		arg.Summary,
		arg.ThumbnailUrl,
		arg.Status,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Summary,
		&i.ThumbnailUrl,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles
WHERE id = $1 AND user_id = $2
`

type DeleteArticleParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteArticle(ctx context.Context, arg DeleteArticleParams) error {
	_, err := q.db.ExecContext(ctx, deleteArticle, arg.ID, arg.UserID)
	return err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
WHERE a.id = $1
`

type GetArticleByIDRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) GetArticleByID(ctx context.Context, id uuid.UUID) (GetArticleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Summary,
		&i.ThumbnailUrl,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.AuthorUsername,
		&i.AuthorName,
		&i.AuthorAvatarUrl,
		&i.TotalClaps,
	)
	return i, err
}

const getFeedArticles = `-- name: GetFeedArticles :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
JOIN follows f ON f.following_id = a.user_id
WHERE f.follower_id = $1 AND a.status = 'published'
ORDER BY a.published_at DESC
LIMIT $2 OFFSET $3
`

type GetFeedArticlesParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetFeedArticlesRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) GetFeedArticles(ctx context.Context, arg GetFeedArticlesParams) ([]GetFeedArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedArticles, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedArticlesRow
	for rows.Next() {
		var i GetFeedArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByAuthor = `-- name: ListArticlesByAuthor :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
WHERE u.username = $1 AND a.status = 'published'
ORDER BY a.published_at DESC
LIMIT $2 OFFSET $3
`

type ListArticlesByAuthorParams struct {
	Username sql.NullString
	Limit    int32
	Offset   int32
}

type ListArticlesByAuthorRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) ListArticlesByAuthor(ctx context.Context, arg ListArticlesByAuthorParams) ([]ListArticlesByAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByAuthor, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArticlesByAuthorRow
	for rows.Next() {
		var i ListArticlesByAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftsByUser = `-- name: ListDraftsByUser :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    0::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
WHERE a.user_id = $1 AND a.status = 'draft'
ORDER BY a.updated_at DESC
LIMIT $2 OFFSET $3
`

type ListDraftsByUserParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type ListDraftsByUserRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) ListDraftsByUser(ctx context.Context, arg ListDraftsByUserParams) ([]ListDraftsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listDraftsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDraftsByUserRow
	for rows.Next() {
		var i ListDraftsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedArticles = `-- name: ListPublishedArticles :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
WHERE a.status = 'published'
ORDER BY a.published_at DESC
LIMIT $1 OFFSET $2
`

type ListPublishedArticlesParams struct {
	Limit  int32
	Offset int32
}

type ListPublishedArticlesRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) ListPublishedArticles(ctx context.Context, arg ListPublishedArticlesParams) ([]ListPublishedArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedArticles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedArticlesRow
	for rows.Next() {
		var i ListPublishedArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishArticle = `-- name: PublishArticle :one
UPDATE articles
SET status = 'published', published_at = NOW(), updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, title, body, summary, thumbnail_url, status, published_at, created_at, updated_at, search_vector
`

type PublishArticleParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) PublishArticle(ctx context.Context, arg PublishArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, publishArticle, arg.ID, arg.UserID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Summary,
		&i.ThumbnailUrl,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const searchArticles = `-- name: SearchArticles :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
WHERE a.status = 'published' AND a.search_vector @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(a.search_vector, plainto_tsquery('english', $1)) DESC
LIMIT $2 OFFSET $3
`

type SearchArticlesParams struct {
	PlaintoTsquery string
	Limit          int32
	Offset         int32
}

type SearchArticlesRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) SearchArticles(ctx context.Context, arg SearchArticlesParams) ([]SearchArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchArticles, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchArticlesRow
	for rows.Next() {
		var i SearchArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE articles
SET title = $2, body = $3, summary = $4, thumbnail_url = $5, updated_at = NOW()
WHERE id = $1 AND user_id = $6
RETURNING id, user_id, title, body, summary, thumbnail_url, status, published_at, created_at, updated_at, search_vector
`

type UpdateArticleParams struct {
	ID           uuid.UUID
	Title        string
	Body         string
	Summary      string
	ThumbnailUrl string
	UserID       uuid.UUID
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, updateArticle,
		arg.ID,
		arg.Title,
		arg.Body,
		arg.Summary,
		arg.ThumbnailUrl,
		arg.UserID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Summary,
		&i.ThumbnailUrl,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}
