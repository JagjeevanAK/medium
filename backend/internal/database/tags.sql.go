// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addArticleTag = `-- name: AddArticleTag :exec
INSERT INTO article_tags (article_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddArticleTagParams struct {
	ArticleID uuid.UUID
	TagID     uuid.UUID
}

func (q *Queries) AddArticleTag(ctx context.Context, arg AddArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, addArticleTag, arg.ArticleID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES (LOWER($1))
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at
`

func (q *Queries) CreateTag(ctx context.Context, lower string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, lower)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getArticleTags = `-- name: GetArticleTags :many
SELECT t.id, t.name, t.created_at FROM tags t
JOIN article_tags at ON t.id = at.tag_id
WHERE at.article_id = $1
ORDER BY t.name
`

func (q *Queries) GetArticleTags(ctx context.Context, articleID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getArticleTags, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at FROM tags
WHERE name = LOWER($1)
`

func (q *Queries) GetTagByName(ctx context.Context, lower string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, lower)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const listArticlesByTag = `-- name: ListArticlesByTag :many
SELECT a.id, a.user_id, a.title, a.body, a.summary, a.thumbnail_url, a.status, a.published_at, a.created_at, a.updated_at, a.search_vector,
    u.username AS author_username,
    u.name AS author_name,
    u.avatar_url AS author_avatar_url,
    COALESCE((SELECT SUM(c.count) FROM claps c WHERE c.article_id = a.id), 0)::int AS total_claps
FROM articles a
JOIN users u ON a.user_id = u.id
JOIN article_tags at ON a.id = at.article_id
JOIN tags t ON at.tag_id = t.id
WHERE t.name = LOWER($1) AND a.status = 'published'
ORDER BY a.published_at DESC
LIMIT $2 OFFSET $3
`

type ListArticlesByTagParams struct {
	Lower  string
	Limit  int32
	Offset int32
}

type ListArticlesByTagRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Title           string
	Body            string
	Summary         string
	ThumbnailUrl    string
	Status          string
	PublishedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	SearchVector    interface{}
	AuthorUsername  sql.NullString
	AuthorName      string
	AuthorAvatarUrl string
	TotalClaps      int32
}

func (q *Queries) ListArticlesByTag(ctx context.Context, arg ListArticlesByTagParams) ([]ListArticlesByTagRow, error) {
	rows, err := q.db.QueryContext(ctx, listArticlesByTag, arg.Lower, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArticlesByTagRow
	for rows.Next() {
		var i ListArticlesByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Summary,
			&i.ThumbnailUrl,
			&i.Status,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.AuthorUsername,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.TotalClaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT t.id, t.name, t.created_at, COUNT(at.article_id)::int AS article_count
FROM tags t
LEFT JOIN article_tags at ON t.id = at.tag_id
LEFT JOIN articles a ON at.article_id = a.id AND a.status = 'published'
GROUP BY t.id
ORDER BY article_count DESC
`

type ListTagsRow struct {
	ID           uuid.UUID
	Name         string
	CreatedAt    time.Time
	ArticleCount int32
}

func (q *Queries) ListTags(ctx context.Context) ([]ListTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsRow
	for rows.Next() {
		var i ListTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.ArticleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeArticleTags = `-- name: RemoveArticleTags :exec
DELETE FROM article_tags
WHERE article_id = $1
`

func (q *Queries) RemoveArticleTags(ctx context.Context, articleID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeArticleTags, articleID)
	return err
}
